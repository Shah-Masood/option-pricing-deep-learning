# -*- coding: utf-8 -*-
"""Optpricing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h-P5jsoo61OXSh6bUhtqmSQI7tEyFOTb

# Simulated Data using Black-Scholes Formula
"""

import numpy as np
from scipy.stats import norm

def black_scholes_call(S, K, T, r, sigma):
  d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
  d2 = d1 - sigma * np.sqrt(T)
  return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

# Simulate 100,000 options

def generate_bs_dataset(n=100000):
  S = np.random.uniform(50, 150, n)      # Stock Price
  K = np.random.uniform(50, 150, n)      # Strike Price
  T = np.random.uniform(0.01, 2, n)      # Time to Maturity (in years)
  r = np.random.uniform(0.01, 0.05, n)   # Risk-Free Rate
  sigma = np.random.uniform(0.1, 0.5, n) # Volatility

  call_prices = black_scholes_call(S, K, T, r, sigma)

  X = np.stack([S, K, T, r, sigma], axis=1)
  y = call_prices
  return X, y

"""# Preprocess the Data"""

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

X, y = generate_bs_dataset()
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

X_train_tensor = torch.tensor(X_train, dtype=torch.float32)
y_train_tensor = torch.tensor(y_train, dtype=torch.float32).view(-1, 1)

print(X_train_tensor.shape)
print(y_train_tensor.shape)

"""# Deep Learning Model"""

import torch
import torch.nn as nn
import torch.optim as optim

class OptionNet(nn.Module):
    def __init__(self):
        super(OptionNet, self).__init__()
        self.net = nn.Sequential(
            nn.Linear(5, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 1)
        )

    def forward(self, x):
        return self.net(x)

model = OptionNet()
loss_fn = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

"""# Train the model"""

for epoch in range(100):
    model.train()
    optimizer.zero_grad()
    output = model(X_train_tensor)
    loss = loss_fn(output, y_train_tensor)
    loss.backward()
    optimizer.step()

    if epoch % 10 == 0:
        print(f"Epoch {epoch}, Loss: {loss.item():.4f}")

"""# Evaluate Performance"""

model.eval()
X_test_tensor = torch.tensor(X_test, dtype=torch.float32)
y_test_tensor = torch.tensor(y_test, dtype=torch.float32).view(-1, 1)
preds = model(X_test_tensor).detach().numpy()

import matplotlib.pyplot as plt

plt.figure(figsize=(6,6))
plt.scatter(y_test, preds, alpha=0.3)
plt.xlabel("True Option Price")
plt.ylabel("Predicted Option Price")
plt.title("DL Predicted vs True (Black-Scholes)")
plt.grid()